# DB 연동 구현 코드 (VectorDB / RAG)

## 1. 데이터베이스 스키마 설계

### 구현 위치
- **파일**: `lab/이인재/규격/database.py`
- **클래스**: `DatabaseManager`

### 테이블 구조

PostgreSQL에서 총 3개의 테이블을 사용합니다.

#### announcements 테이블
웹 크롤링을 통해 수집한 공고 메타데이터를 저장하는 테이블입니다.

**주요 컬럼**:
- `id`: 공고 고유 ID (Primary Key)
- `notice_type`: 공고 유형 (국민임대, 행복주택 등)
- `category`: 카테고리 (lease/sale)
- `title`: 공고 제목
- `region`: 지역
- `posted_date`: 게시일
- `deadline_date`: 마감일
- `status`: 상태
- `view_count`: 조회수
- `url`: 공고 URL
- `is_vectorized`: 벡터화 완료 여부 (Boolean)
- `vectorized_at`: 벡터화 완료 시각 (Timestamp)
- `created_at`: 생성 시각 (Timestamp)
- `updated_at`: 수정 시각 (Timestamp)

#### announcement_files 테이블
각 공고에 해당하는 PDF 문서 다운로드 정보를 저장하는 테이블입니다.

**주요 컬럼**:
- `id`: 파일 고유 ID (Primary Key)
- `announcement_id`: 공고 ID (Foreign Key → announcements.id)
- `file_name`: 파일명
- `file_path`: 파일 경로
- `is_vectorized`: 벡터화 완료 여부 (Boolean)
- `vectorized_at`: 벡터화 완료 시각 (Timestamp)
- `created_at`: 생성 시각 (Timestamp)

#### document_chunks 테이블
공고 PDF 문서를 청킹하고 임베딩한 벡터를 저장하는 테이블입니다. RDB와 VectorDB의 역할을 동시에 수행합니다.

**주요 컬럼**:
- `id`: 청크 고유 ID (Primary Key)
- `announcement_id`: 공고 ID (Foreign Key → announcements.id)
- `file_id`: 파일 ID (Foreign Key → announcement_files.id)
- `chunk_text`: 청크 텍스트
- `chunk_index`: 청크 인덱스
- `page_number`: 페이지 번호 (NULL 가능)
- `embedding`: 임베딩 벡터 (pgvector 타입, vector(1024))
- `metadata`: 메타데이터 (JSONB)
  - `section`: 섹션 정보
  - `file_name`: 파일명
  - `has_table`: 테이블 포함 여부
  - `chunk_length`: 청크 길이

---

## 2. 벡터 검색 구현

### 구현 위치
- **파일**: `back-end/zip_fit/gongo.py`

### 주요 함수

#### vector_search()
벡터 유사도 검색을 수행합니다.

**시그니처**:
```python
async def vector_search(
    query: str, 
    top_k: int = 15, 
    filters: dict = None, 
    filter_ids: List[str] = None
) -> List[Dict]
```

**기능**:
- 사용자 질문을 임베딩 벡터로 변환
- pgvector의 cosine distance 연산자 (`<=>`) 사용
- 지역, 유형, 카테고리별 필터링 지원
- 특정 공고 ID 범위 내 검색 지원

**SQL 쿼리 예시**:
```sql
SELECT dc.id as chunk_id, dc.announcement_id, a.title, a.category, 
       a.region, a.notice_type, a.posted_date, dc.chunk_text, 
       dc.chunk_index, dc.metadata, 
       (1 - (dc.embedding <=> $1::vector)) as similarity
FROM document_chunks dc
JOIN announcements a ON dc.announcement_id = a.id
WHERE 1=1 [필터 조건]
ORDER BY dc.embedding <=> $1::vector
LIMIT $2
```

#### keyword_search()
키워드 기반 검색을 수행합니다.

**시그니처**:
```python
async def keyword_search(
    keywords: List[str], 
    top_k: int = 10, 
    filters: dict = None, 
    filter_ids: List[str] = None
) -> List[Dict]
```

**기능**:
- LIKE 연산자를 사용한 부분 문자열 매칭
- 여러 키워드 OR 조건으로 검색
- 필터링 지원

#### multi_query_hybrid_search()
멀티쿼리 하이브리드 검색을 수행합니다.

**시그니처**:
```python
async def multi_query_hybrid_search(
    query_analysis: Dict,
    multi_queries: List[str],
    vector_top_k: int = 10,
    keyword_top_k: int = 5
) -> List[Dict]
```

**기능**:
- 여러 쿼리에 대해 벡터 검색 및 키워드 검색 병렬 수행
- 결과 병합 및 중복 제거
- 필터링 지원

#### rerank_results()
검색 결과를 재순위화합니다.

**시그니처**:
```python
def rerank_results(
    query: str, 
    search_results: List[Dict], 
    top_k: int = 8
) -> List[Dict]
```

**기능**:
- Cross-Encoder 모델을 사용한 점수 재계산
- Rerank 점수 기준 정렬
- `USE_RERANKER` 설정에 따라 활성화/비활성화

#### merge_chunks()
동일 공고의 여러 청크를 병합합니다.

**시그니처**:
```python
async def merge_chunks(chunks: List[Dict]) -> List[Dict]
```

**기능**:
- 공고별로 청크 그룹화
- 청크 인덱스 순서로 정렬
- 병합된 텍스트 생성
- 최고 점수 유지

#### build_context()
검색된 공고 정보를 구조화된 컨텍스트로 구성합니다.

**시그니처**:
```python
def build_context(merged_results: List[Dict]) -> str
```

**기능**:
- 공고별로 구조화된 형식으로 구성
- 공고 제목, 지역, 유형, 관련도 점수 포함
- 문서 내용 포함

---

## 3. 데이터베이스 관리

### DatabaseManager 클래스
- **구현 위치**: `lab/이인재/규격/database.py`

### 주요 메서드

#### get_connection()
데이터베이스 연결을 생성합니다.

#### execute_query()
쿼리를 실행하고 결과를 반환합니다.

#### execute_command()
쿼리를 실행합니다 (반환값 없음).

#### get_vectorization_progress()
벡터화 진행 상황을 조회합니다.

**반환 형식**:
```python
{
    'category': {
        'vectorized': int,
        'total': int,
        'percentage': float
    }
}
```

#### get_unvectorized_announcements()
미벡터화 공고를 조회합니다.

#### insert_chunk()
청크 및 임베딩을 저장합니다.

**파라미터**:
- `announcement_id`: 공고 ID
- `file_id`: 파일 ID
- `chunk_text`: 청크 텍스트
- `chunk_index`: 청크 인덱스
- `embedding`: 임베딩 벡터 (List[float])
- `metadata`: 메타데이터 (Dict)

#### mark_file_vectorized()
파일 벡터화 완료를 표시합니다.

#### mark_announcement_vectorized()
공고 벡터화 완료를 표시합니다.

---

## 4. 데이터 임포트

### 구현 위치
- **파일**: `lab/이인재/규격/import_csv_to_db.py`

### 기능
- CSV 파일에서 공고 메타데이터를 데이터베이스에 임포트
- 데이터 검증 및 정제
- 중복 제거

---

## 5. 벡터 검색 최적화

### 인덱싱
- pgvector의 HNSW 인덱스 활용 (향후 구현 예정)
- 벡터 검색 성능 향상

### 필터링 최적화
- WHERE 절에 필터 조건 적용
- 인덱스 활용 가능한 조건 우선 사용

### 쿼리 최적화
- JOIN 최적화
- LIMIT 절 활용
- DISTINCT ON 활용 (키워드 검색)

---

## 6. 연결 관리

### 비동기 연결
- **라이브러리**: asyncpg
- **설정**: `back-end/zip_fit/config.py`
- **연결 정보**: 환경 변수에서 로드 (`.env` 파일)

### 연결 설정
```python
DB_CONFIG = {
    'host': os.getenv('DB_HOST'),
    'port': int(os.getenv('DB_PORT')),
    'user': os.getenv('DB_USER'),
    'password': os.getenv('DB_PASSWORD'),
    'database': os.getenv('DB_DATABASE')
}
```

### 연결 풀링
- 각 요청마다 새로운 연결 생성
- 연결 후 자동으로 닫힘 (`try-finally` 사용)

---

## 7. 주요 구현 파일

### Backend
- `back-end/zip_fit/gongo.py`: 벡터 검색, 키워드 검색, 하이브리드 검색, 재순위화 구현
- `back-end/zip_fit/config.py`: 데이터베이스 연결 설정 및 RAG 파라미터 설정
- `back-end/zip_fit/dependencies.py`: 데이터베이스 연결 및 모델 로딩 관리

### 데이터베이스 관리
- `lab/이인재/규격/database.py`: 데이터베이스 관리 클래스 (벡터화 진행 상황 추적, 청크 저장 등)
- `lab/이인재/규격/import_csv_to_db.py`: CSV 데이터 임포트 스크립트

---

## 8. 사용 예시

### 벡터 검색 예시
```python
# 필터 없이 검색
results = await vector_search("서울 행복주택", top_k=10)

# 지역 필터 적용
results = await vector_search(
    "행복주택", 
    top_k=10, 
    filters={'region': '서울'}
)

# 특정 공고 ID 범위 내 검색
results = await vector_search(
    "자격 조건", 
    top_k=5, 
    filter_ids=['LH_lease_1', 'LH_lease_2']
)
```

### 하이브리드 검색 예시
```python
query_analysis = {
    'region': '서울',
    'notice_type': '행복주택',
    'category': 'lease',
    'search_keywords': ['서울', '행복주택']
}
multi_queries = ['서울 행복주택', '서울 지역 행복주택 신청']

results = await multi_query_hybrid_search(
    query_analysis, 
    multi_queries
)
```

